/*
 * Arduino IRremote Daikin 2015
 * Copyright 2015 danny
 *
 *
 * enableIROut declare base on  Ken Shirriff's IRremote library.
 * http://arcfn.com/2009/08/multi-protocol-infrared-remote-library.html
 *
 *
 */

#define F_CPU 16000000UL
#include <pololu/time.h>
#include <util/delay.h>
#include <avr/io.h>
#define delay(n) _delay_ms(n)

#ifndef IRremoteDaikinSend_h
#define IRremoteDaikinSend_h
	void sendRaw(unsigned int buf[], int len, int hz);
	void sendDaikin(unsigned char buf[], int len,int start);
	void sendDaikinWake();
	// private:
	void enableIROut(int khz);
	void setPin();
	void mark(int usec);
	void space(int usec);
#endif
#ifndef IRremoteintDaikin_h
#define IRremoteintDaikin_h
#ifdef F_CPU
#define SYSCLOCK F_CPU     // main Arduino clock
#else
#define SYSCLOCK 16000000  // main Arduino clock
#endif

//DAIKIN
#define DAIKIN_HDR_MARK	    3600 //DAIKIN_ZERO_MARK*8
#define DAIKIN_HDR_SPACE	1600 //DAIKIN_ZERO_MARK*4
#define DAIKIN_ONE_SPACE	1300
#define DAIKIN_ONE_MARK	    380
#define DAIKIN_ZERO_MARK	380
#define DAIKIN_ZERO_SPACE   380
#endif

//==============================================================================
//                         AAA   IIIII  W   W   AAA
//                        A   A    I    W   W  A   A
//                        AAAAA    I    W W W  AAAAA
//                        A   A    I    W W W  A   A
//                        A   A  IIIII   WWW   A   A
//==============================================================================

// Based off the RC-T501 RCU
// Lirc file http://lirc.sourceforge.net/remotes/aiwa/RC-T501

//+=============================================================================
#if SEND_AIWA_RC_T501 == 1

	#define AIWA_RC_T501_HZ            38
	#define AIWA_RC_T501_BITS          15
	#define AIWA_RC_T501_PRE_BITS      26
	#define AIWA_RC_T501_POST_BITS      1
	#define AIWA_RC_T501_SUM_BITS    (AIWA_RC_T501_PRE_BITS + AIWA_RC_T501_BITS + AIWA_RC_T501_POST_BITS)
	#define AIWA_RC_T501_HDR_MARK    8800
	#define AIWA_RC_T501_HDR_SPACE   4500
	#define AIWA_RC_T501_BIT_MARK     500
	#define AIWA_RC_T501_ONE_SPACE    600
	#define AIWA_RC_T501_ZERO_SPACE  1700
	void  sendAiwaRCT501(int code){
		int i;
		unsigned long  mask;
		unsigned long  pre = 0x0227EEC0;  // 26-bits

		// Set IR carrier frequency
		enableIROut(AIWA_RC_T501_HZ);

		// Header
		mark(AIWA_RC_T501_HDR_MARK);
		space(AIWA_RC_T501_HDR_SPACE);

		// Send "pre" data
		for (mask = 1UL << (26 - 1);  mask;  mask >>= 1) {
			mark(AIWA_RC_T501_BIT_MARK);
			if (pre & mask)  space(AIWA_RC_T501_ONE_SPACE) ;
			else             space(AIWA_RC_T501_ZERO_SPACE) ;
		}

	//-v- THIS CODE LOOKS LIKE IT MIGHT BE WRONG - CHECK!
	//    it only send 15bits and ignores the top bit
	//    then uses TOPBIT which is 0x80000000 to check the bit code
	//    I suspect TOPBIT should be changed to 0x00008000

		// Skip first code bit
		code <<= 1;
		// Send code
		for (i = 0;  i < 15;  i++) {
			mark(AIWA_RC_T501_BIT_MARK);
			if (code & 0x80000000)  space(AIWA_RC_T501_ONE_SPACE) ;
			else                    space(AIWA_RC_T501_ZERO_SPACE) ;
			code <<= 1;
		}

	//-^- THIS CODE LOOKS LIKE IT MIGHT BE WRONG - CHECK!

		// POST-DATA, 1 bit, 0x0
		mark(AIWA_RC_T501_BIT_MARK);
		space(AIWA_RC_T501_ZERO_SPACE);

		mark(AIWA_RC_T501_BIT_MARK);
		space(0);
	}
#endif

//==============================================================================
//                 DAIKIN
//==============================================================================

//DAIKIN

#if SEND_DAIKIN == 1
	#define DAIKIN_HDR_MARK	    3600 //DAIKIN_ZERO_MARK*8
	#define DAIKIN_HDR_SPACE	1600 //DAIKIN_ZERO_MARK*4
	#define DAIKIN_ONE_SPACE	1300
	#define DAIKIN_ONE_MARK	    380
	#define DAIKIN_ZERO_MARK	380
	#define DAIKIN_ZERO_SPACE   380
	void sendDaikin(unsigned char buf[], int len, int start) {
		int data2, i, j;
		enableIROut(38);
		
		mark(DAIKIN_HDR_MARK);
		space(DAIKIN_HDR_SPACE);

		for (i = start; i < start+len; i++) {
			data2=buf[i];
			for (j = 0; j < 8; j++) {
				if ((1 << j & data2)) {
					mark(DAIKIN_ONE_MARK);
					space(DAIKIN_ONE_SPACE);
				}else{
					mark(DAIKIN_ZERO_MARK);
					space(DAIKIN_ZERO_SPACE);
				}
			}
		}
		mark(DAIKIN_ONE_MARK);
		space(DAIKIN_ZERO_SPACE);
	}

	void sendDaikinWake() {
		enableIROut(38);
		space(DAIKIN_ZERO_MARK);
		//
		mark(DAIKIN_ZERO_MARK);
		space(DAIKIN_ZERO_MARK);
		//
		mark(DAIKIN_ZERO_MARK);
		space(DAIKIN_ZERO_MARK);
		//
		mark(DAIKIN_ZERO_MARK);
		space(DAIKIN_ZERO_MARK);
		//
		mark(DAIKIN_ZERO_MARK);
		space(DAIKIN_ZERO_MARK);
		//
		mark(DAIKIN_ZERO_MARK);
		space(DAIKIN_ZERO_MARK);
	}
#endif

// Reverse Engineered by looking at RAW dumps generated by IRremote

// I have since discovered that Denon publish all their IR codes:
//  https://www.google.co.uk/search?q=DENON+MASTER+IR+Hex+Command+Sheet
//  -> http://assets.denon.com/documentmaster/us/denon%20master%20ir%20hex.xls

// Having looked at the official Denon Pronto sheet and reverse engineered
// the timing values from it, it is obvious that Denon have a range of
// different timings and protocols ...the values here work for my AVR-3801 Amp!

//==============================================================================
//                    DDDD   EEEEE  N   N   OOO   N   N
//                     D  D  E      NN  N  O   O  NN  N
//                     D  D  EEE    N N N  O   O  N N N
//                     D  D  E      N  NN  O   O  N  NN
//                    DDDD   EEEEE  N   N   OOO   N   N
//==============================================================================
#if SEND_DENON == 1

	#define DENON_BITS          14  // The number of bits in the command

	#define DENON_HDR_MARK     300  // The length of the Header:Mark
	#define DENON_HDR_SPACE    750  // The lenght of the Header:Space

	#define DENON_BIT_MARK     300  // The length of a Bit:Mark
	#define DENON_ONE_SPACE   1800  // The length of a Bit:Space for 1's
	#define DENON_ZERO_SPACE   750  // The length of a Bit:Space for 0's

	//+=============================================================================
	//
	void  sendDenon(unsigned long data,  int nbits){
		unsigned long  mask;
		// Set IR carrier frequency
		enableIROut(38);

		// Header
		mark (DENON_HDR_MARK);
		space(DENON_HDR_SPACE);

		// Data
		for (mask = 1UL << (nbits - 1);  mask;  mask >>= 1) {
			if (data & mask) {
				mark (DENON_BIT_MARK);
				space(DENON_ONE_SPACE);
			} else {
				mark (DENON_BIT_MARK);
				space(DENON_ZERO_SPACE);
			}
		}

		// Footer
		mark(DENON_BIT_MARK);
		space(0);  // Always end with the LED off
	}
#endif

//==============================================================================
//                       DDDD   IIIII   SSSS  H   H
//                        D  D    I    S      H   H
//                        D  D    I     SSS   HHHHH
//                        D  D    I        S  H   H
//                       DDDD   IIIII  SSSS   H   H
//==============================================================================

// Sharp and DISH support by Todd Treece ( http://unionbridge.org/design/ircommand )
//
// The sned function needs to be repeated 4 times
//
// Only send the last for characters of the hex.
// I.E.  Use 0x1C10 instead of 0x0000000000001C10 as listed in the LIRC file.
//
// Here is the LIRC file I found that seems to match the remote codes from the
// oscilloscope:
//   DISH NETWORK (echostar 301):
//   http://lirc.sourceforge.net/remotes/echostar/301_501_3100_5100_58xx_59xx

//+=============================================================================
#if SEND_DISH == 1
	#define DISH_BITS          16
	#define DISH_HDR_MARK     400
	#define DISH_HDR_SPACE   6100
	#define DISH_BIT_MARK     400
	#define DISH_ONE_SPACE   1700
	#define DISH_ZERO_SPACE  2800
	#define DISH_RPT_SPACE   6200
	void  sendDISH(unsigned long data,  int nbits){
		unsigned long  mask;
		// Set IR carrier frequency
		enableIROut(56);

		mark(DISH_HDR_MARK);
		space(DISH_HDR_SPACE);

		for (mask = 1UL << (nbits - 1);  mask;  mask >>= 1) {
			if (data & mask) {
				mark(DISH_BIT_MARK);
				space(DISH_ONE_SPACE);
			} else {
				mark(DISH_BIT_MARK);
				space(DISH_ZERO_SPACE);
			}
		}
	}
#endif

//==============================================================================
//                             JJJJJ  V   V   CCCC
//                               J    V   V  C
//                               J     V V   C
//                             J J     V V   C
//                              J       V     CCCC
//==============================================================================

//+=============================================================================
// JVC does NOT repeat by sending a separate code (like NEC does).
// The JVC protocol repeats by skipping the header.
// To send a JVC repeat signal, send the original code value
//   and set 'repeat' to true
//
#if SEND_JVC == 1
	#define JVC_BITS           16
	#define JVC_HDR_MARK     8000
	#define JVC_HDR_SPACE    4000
	#define JVC_BIT_MARK      600
	#define JVC_ONE_SPACE    1600
	#define JVC_ZERO_SPACE    550
	#define JVC_RPT_LENGTH  60000
	void  sendJVC (unsigned long data,  int nbits,  bool repeat){
		unsigned long  mask;
		// Set IR carrier frequency
		enableIROut(38);

		// Only send the Header if this is NOT a repeat command
		if (!repeat){
			mark(JVC_HDR_MARK);
			space(JVC_HDR_SPACE);
		}

		// Data
		for (mask = 1UL << (nbits - 1);  mask;  mask >>= 1) {
			if (data & mask) {
				mark(JVC_BIT_MARK);
				space(JVC_ONE_SPACE);
			} else {
				mark(JVC_BIT_MARK);
				space(JVC_ZERO_SPACE);
			}
		}

		// Footer
		mark(JVC_BIT_MARK);
		space(0);  // Always end with the LED off
	}
#endif

//==============================================================================
//                               L       GGGG
//                               L      G
//                               L      G  GG
//                               L      G   G
//                               LLLLL   GGG
//==============================================================================

#if SEND_LG == 1

	#define LG_BITS 28
	#define LG_HDR_MARK 8000
	#define LG_HDR_SPACE 4000
	#define LG_BIT_MARK 600
	#define LG_ONE_SPACE 1600
	#define LG_ZERO_SPACE 550
	#define LG_RPT_LENGTH 60000

	void sendLG(unsigned long data,  int nbits){
		unsigned long  mask;
		// Set IR carrier frequency
		enableIROut(38);

		// Header
		mark(LG_HDR_MARK);
		space(LG_HDR_SPACE);
		mark(LG_BIT_MARK);

		// Data
		for (mask = 1UL << (nbits - 1);  mask;  mask >>= 1) {
			if (data & mask) {
				space(LG_ONE_SPACE);
				mark(LG_BIT_MARK);
			} else {
				space(LG_ZERO_SPACE);
				mark(LG_BIT_MARK);
			}
		}
		space(0);  // Always end with the LED off
	}
#endif

//==============================================================================
//                           N   N  EEEEE   CCCC
//                           NN  N  E      C
//                           N N N  EEE    C
//                           N  NN  E      C
//                           N   N  EEEEE   CCCC
//==============================================================================

#if SEND_NEC == 1

	#define NEC_BITS          32
	#define NEC_HDR_MARK    9000
	#define NEC_HDR_SPACE   4500
	#define NEC_BIT_MARK     560
	#define NEC_ONE_SPACE   1690
	#define NEC_ZERO_SPACE   560
	#define NEC_RPT_SPACE   2250

	//+=============================================================================
	void  sendNEC (unsigned long data,  int nbits){
		unsigned long  mask;
		// Set IR carrier frequency
		enableIROut(38);

		// Header
		mark(NEC_HDR_MARK);
		space(NEC_HDR_SPACE);

		// Data
		for (mask = 1UL << (nbits - 1);  mask;  mask >>= 1) {
			if (data & mask) {
				mark(NEC_BIT_MARK);
				space(NEC_ONE_SPACE);
			} else {
				mark(NEC_BIT_MARK);
				space(NEC_ZERO_SPACE);
			}
		}

		// Footer
		mark(NEC_BIT_MARK);
		space(0);  // Always end with the LED off
	}
#endif

//==============================================================================
//       PPPP    AAA   N   N   AAA    SSSS   OOO   N   N  IIIII   CCCC
//       P   P  A   A  NN  N  A   A  S      O   O  NN  N    I    C
//       PPPP   AAAAA  N N N  AAAAA   SSS   O   O  N N N    I    C
//       P      A   A  N  NN  A   A      S  O   O  N  NN    I    C
//       P      A   A  N   N  A   A  SSSS    OOO   N   N  IIIII   CCCC
//==============================================================================

//+=============================================================================
#if SEND_PANASONIC == 1
	#define PANASONIC_BITS          48
	#define PANASONIC_HDR_MARK    3502
	#define PANASONIC_HDR_SPACE   1750
	#define PANASONIC_BIT_MARK     502
	#define PANASONIC_ONE_SPACE   1244
	#define PANASONIC_ZERO_SPACE   400
	void  sendPanasonic (unsigned int address,  unsigned long data){
		unsigned long  mask;
		// Set IR carrier frequency
		enableIROut(35);

		// Header
		mark(PANASONIC_HDR_MARK);
		space(PANASONIC_HDR_SPACE);

		// Address
		for (mask = 1UL << (16 - 1);  mask;  mask >>= 1) {
			mark(PANASONIC_BIT_MARK);
			if (address & mask)  space(PANASONIC_ONE_SPACE) ;
			else                 space(PANASONIC_ZERO_SPACE) ;
		}

		// Data
		for (mask = 1UL << (32 - 1);  mask;  mask >>= 1) {
			mark(PANASONIC_BIT_MARK);
			if (data & mask)  space(PANASONIC_ONE_SPACE) ;
			else              space(PANASONIC_ZERO_SPACE) ;
		}

		// Footer
		mark(PANASONIC_BIT_MARK);
		space(0);  // Always end with the LED off
	}
#endif

//==============================================================================
//                       PRONTO
//==============================================================================

#if SEND_PRONTO == 1

	//+=============================================================================
	// Check for a valid hex digit
	//
	bool  pronto_ishex (char ch){
		return ( ((ch >= '0') && (ch <= '9')) ||
	             ((ch >= 'A') && (ch <= 'F')) ||
	             ((ch >= 'a') && (ch <= 'f'))   ) ? true : false ;
	}

	//+=============================================================================
	// Check for a valid "blank" ... '\0' is a valid "blank"
	//
	bool  pronto_isblank (char ch){
		return ((ch == ' ') || (ch == '\t') || (ch == '\0')) ? true : false ;
	}

	//+=============================================================================
	// Bypass spaces
	//
	void  pronto_byp (char** pcp){
		while (pronto_isblank(**pcp))  (*pcp)++ ;
	}

	//+=============================================================================
	// Hex-to-Byte : Decode a hex digit
	// We assume the character has already been validated
	//
	uint8_t  pronto_htob(char ch){
		if ((ch >= '0') && (ch <= '9'))  return ch - '0' ;
		if ((ch >= 'A') && (ch <= 'F'))  return ch - 'A' + 10 ;
		if ((ch >= 'a') && (ch <= 'f'))  return ch - 'a' + 10 ;
		return (uint8_t)ch;
	}

	//+=============================================================================
	// Hex-to-Word : Decode a block of 4 hex digits
	// We assume the string has already been validated
	//   and the pointer being passed points at the start of a block of 4 hex digits
	//
	uint16_t pronto_htow(char* cp){
		return ( (pronto_htob(cp[0]) << 12) | (pronto_htob(cp[1]) <<  8) |
	             (pronto_htob(cp[2]) <<  4) | (pronto_htob(cp[3])      )  ) ;
	}

	//+=============================================================================
	//
	bool sendPronto (char* s,  bool repeat,  bool fallback){
		int       i;
		int       len;
		int       skip;
		char*     cp;
		uint16_t  freq;  // Frequency in KHz
		uint8_t   usec;  // pronto uSec/tick
		uint8_t   once;
		uint8_t   rpt;

		// Validate the string
		for (cp = s;  *cp;  cp += 4) {
			pronto_byp(&cp);
			if ( !pronto_ishex(cp[0]) || !pronto_ishex(cp[1]) ||
			     !pronto_ishex(cp[2]) || !pronto_ishex(cp[3]) || !pronto_isblank(cp[4]) )  return false ;
		}

		// We will use cp to traverse the string
		cp = s;

		// Check mode = Oscillated/Learned
		pronto_byp(&cp);
		if (pronto_htow(cp) != 0000)  return false;
		cp += 4;

		// Extract & set frequency
		pronto_byp(&cp);
		freq = (int)(1000000 / (pronto_htow(cp) * 0.241246));  // Rounding errors will occur, tolerance is +/- 10%
		usec = (int)(((1.0 / freq) * 1000000) + 0.5);  // Another rounding error, thank Cod for analogue electronics
		freq /= 1000;  // This will introduce a(nother) rounding error which we do not want in the usec calcualtion
		cp += 4;

		// Get length of "once" code
		pronto_byp(&cp);
		once = pronto_htow(cp);
		cp += 4;

		// Get length of "repeat" code
		pronto_byp(&cp);
		rpt = pronto_htow(cp);
		cp += 4;

		// Which code are we sending?
		if (fallback) { // fallback on the "other" code if "this" code is not present
			if (!repeat) { // requested 'once'
				if (once)  len = once * 2,  skip = 0 ;  // if once exists send it
				else       len = rpt  * 2,  skip = 0 ;  // else send repeat code
			} else { // requested 'repeat'
				if (rpt)   len = rpt  * 2,  skip = 0 ;  // if rpt exists send it
				else       len = once * 2,  skip = 0 ;  // else send once code
			}
		} else {  // Send what we asked for, do not fallback if the code is empty!
			if (!repeat)  len = once * 2,  skip = 0 ;     // 'once' starts at 0
			else          len = rpt  * 2,  skip = once ;  // 'repeat' starts where 'once' ends
	    }

		// Skip to start of code
		for (i = 0;  i < skip;  i++, cp += 4)  pronto_byp(&cp) ;

		// Send code
		enableIROut(freq);
		for (i = 0;  i < len;  i++) {
			pronto_byp(&cp);
			if (i & 1)  space(pronto_htow(cp) * usec);
			else        mark (pronto_htow(cp) * usec);
			cp += 4;
		}
		return true;
	}
#endif // SEND_PRONTO


//==============================================================================
//                          RRRR    CCCC  55555
//                          R   R  C      5
//                          RRRR   C      5555
//                          R  R   C          5
//                          R   R   CCCC  5555
//
// NB: First bit must be a one (start bit)

//+=============================================================================

#if SEND_RC5 == 1
	//
	#define MIN_RC5_SAMPLES     11
	#define RC5_T1             889
	#define RC5_RPT_LENGTH   46000
	void  sendRC5(unsigned long data,  int nbits){
		unsigned long  mask;
		// Set IR carrier frequency
		enableIROut(36);

		// Start
		mark(RC5_T1);
		space(RC5_T1);
		mark(RC5_T1);

		// Data
		for (mask = 1UL << (nbits - 1);  mask;  mask >>= 1) {
			if (data & mask) {
				space(RC5_T1); // 1 is space, then mark
				mark(RC5_T1);
			} else {
				mark(RC5_T1);
				space(RC5_T1);
			}
		}
		space(0);  // Always end with the LED off
	}
#endif

//+=============================================================================
//                           RRRR    CCCC   6666
//                           R   R  C      6
//                           RRRR   C      6666
//                           R  R   C      6   6
//                           R   R   CCCC   666
//
// NB : Caller needs to take care of flipping the toggle bit
//

#if SEND_RC6 == 1
	#define MIN_RC6_SAMPLES      1
	#define RC6_HDR_MARK      2666
	#define RC6_HDR_SPACE      889
	#define RC6_T1             444
	#define RC6_RPT_LENGTH   46000
	void  sendRC6 (unsigned long data,  int nbits){
		unsigned long  i, mask;
		int t;
		// Set IR carrier frequency
		enableIROut(36);

		// Header
		mark(RC6_HDR_MARK);
		space(RC6_HDR_SPACE);

		// Start bit
		mark(RC6_T1);
		space(RC6_T1);

		// Data
		for (i = 1, mask = 1UL << (nbits - 1);  mask;  i++, mask >>= 1) {
			// The fourth bit we send is a "double width trailer bit"
			t = (i == 4) ? (RC6_T1 * 2) : (RC6_T1) ;
			if (data & mask) {
				mark(t);
				space(t);
			}else{
				space(t);
				mark(t);
			}
		}
		space(0);  // Always end with the LED off
	}
#endif

//==============================================================================
//              SSSS   AAA    MMM    SSSS  U   U  N   N   GGGG
//             S      A   A  M M M  S      U   U  NN  N  G
//              SSS   AAAAA  M M M   SSS   U   U  N N N  G  GG
//                 S  A   A  M   M      S  U   U  N  NN  G   G
//             SSSS   A   A  M   M  SSSS    UUU   N   N   GGG
//==============================================================================

//+=============================================================================
#if SEND_SAMSUNG == 1

	#define SAMSUNG_BITS          32
	#define SAMSUNG_HDR_MARK    5000
	#define SAMSUNG_HDR_SPACE   5000
	#define SAMSUNG_BIT_MARK     560
	#define SAMSUNG_ONE_SPACE   1600
	#define SAMSUNG_ZERO_SPACE   560
	#define SAMSUNG_RPT_SPACE   2250
	void  sendSAMSUNG (unsigned long data,  int nbits){
		unsigned long  mask;
		// Set IR carrier frequency
		enableIROut(38);

		// Header
		mark(SAMSUNG_HDR_MARK);
		space(SAMSUNG_HDR_SPACE);

		// Data
		for (mask = 1UL << (nbits - 1);  mask;  mask >>= 1) {
			if (data & mask) {
				mark(SAMSUNG_BIT_MARK);
				space(SAMSUNG_ONE_SPACE);
			} else {
				mark(SAMSUNG_BIT_MARK);
				space(SAMSUNG_ZERO_SPACE);
			}
		}

		// Footer
		mark(SAMSUNG_BIT_MARK);
		space(0);  // Always end with the LED off
	}
#endif

//==============================================================================
//                       SSSS  H   H   AAA   RRRR   PPPP
//                      S      H   H  A   A  R   R  P   P
//                       SSS   HHHHH  AAAAA  RRRR   PPPP
//                          S  H   H  A   A  R  R   P
//                      SSSS   H   H  A   A  R   R  P
//==============================================================================

// Sharp and DISH support by Todd Treece: http://unionbridge.org/design/ircommand
//
// The send function has the necessary repeat built in because of the need to
// invert the signal.
//
// Sharp protocol documentation:
//   http://www.sbprojects.com/knowledge/ir/sharp.htm
//
// Here is the LIRC file I found that seems to match the remote codes from the
// oscilloscope:
//   Sharp LCD TV:
//   http://lirc.sourceforge.net/remotes/sharp/GA538WJSA
//+=============================================================================
#if SEND_SHARP == 1

	#define SHARP_BITS             15
	#define SHARP_BIT_MARK        245
	#define SHARP_ONE_SPACE      1805
	#define SHARP_ZERO_SPACE      795
	#define SHARP_GAP          600000
	#define SHARP_RPT_SPACE      3000

	#define SHARP_TOGGLE_MASK  0x3FF

	void sendSharpRaw(unsigned long data,  int nbits){
		int n;
		unsigned long  mask;
		enableIROut(38);

		// Sending codes in bursts of 3 (normal, inverted, normal) makes transmission
		// much more reliable. That's the exact behaviour of CD-S6470 remote control.
		for (n = 0;  n < 3;  n++) {
			for (mask = 1UL << (nbits - 1);  mask;  mask >>= 1) {
				if (data & mask) {
					mark(SHARP_BIT_MARK);
					space(SHARP_ONE_SPACE);
				} else {
					mark(SHARP_BIT_MARK);
					space(SHARP_ZERO_SPACE);
				}
			}

			mark(SHARP_BIT_MARK);
			space(SHARP_ZERO_SPACE);
			_delay_ms(40);

			data = data ^ SHARP_TOGGLE_MASK;
		}
	}

	//+=============================================================================
	// Sharp send compatible with data obtained through decodeSharp()
	//                                                  ^^^^^^^^^^^^^ FUNCTION MISSING!
	//
	void sendSharp (unsigned int address,  unsigned int command){
		sendSharpRaw((address << 10) | (command << 2) | 2, SHARP_BITS);
	}
#endif

//==============================================================================
//                           SSSS   OOO   N   N  Y   Y
//                          S      O   O  NN  N   Y Y
//                           SSS   O   O  N N N    Y
//                              S  O   O  N  NN    Y
//                          SSSS    OOO   N   N    Y
//==============================================================================

//+=============================================================================
#if SEND_SONY == 1

	#define SONY_BITS                   12
	#define SONY_HDR_MARK             2400
	#define SONY_HDR_SPACE             600
	#define SONY_ONE_MARK             1200
	#define SONY_ZERO_MARK             600
	#define SONY_RPT_LENGTH          45000
	#define SONY_DOUBLE_SPACE_USECS    500  // usually ssee 713 - not using ticks as get number wrapround
	void  sendSony (unsigned long data,  int nbits){
		unsigned long  mask;
		// Set IR carrier frequency
		enableIROut(40);

		// Header
		mark(SONY_HDR_MARK);
		space(SONY_HDR_SPACE);

		// Data
		for (mask = 1UL << (nbits - 1);  mask;  mask >>= 1) {
			if (data & mask) {
				mark(SONY_ONE_MARK);
				space(SONY_HDR_SPACE);
			} else {
				mark(SONY_ZERO_MARK);
				space(SONY_HDR_SPACE);
			}
		}

		// We will have ended with LED off
	}
#endif
//==============================================================================
//               W   W  H   H  Y   Y N   N TTTTT EEEEE  RRRRR
//               W   W  H   H   Y Y  NN  N   T   E      R   R
//               W W W  HHHHH    Y   N N N   T   EEE    RRRR
//               W W W  H   H    Y   N  NN   T   E      R  R
//                WWW   H   H    Y   N   N   T   EEEEE  R   R
//==============================================================================

//+=============================================================================
#if SEND_WHYNTER == 1

	#define WHYNTER_BITS          32
	#define WHYNTER_HDR_MARK    2850
	#define WHYNTER_HDR_SPACE   2850
	#define WHYNTER_BIT_MARK     750
	#define WHYNTER_ONE_MARK     750
	#define WHYNTER_ONE_SPACE   2150
	#define WHYNTER_ZERO_MARK    750
	#define WHYNTER_ZERO_SPACE   750
	void  sendWhynter (unsigned long data,  int nbits){
		unsigned long  mask;
		// Set IR carrier frequency
		enableIROut(38);

		// Start
		mark(WHYNTER_ZERO_MARK);
		space(WHYNTER_ZERO_SPACE);

		// Header
		mark(WHYNTER_HDR_MARK);
		space(WHYNTER_HDR_SPACE);

		// Data
		for (mask = 1UL << (nbits - 1);  mask;  mask >>= 1) {
			if (data & mask) {
				mark(WHYNTER_ONE_MARK);
				space(WHYNTER_ONE_SPACE);
			} else {
				mark(WHYNTER_ZERO_MARK);
				space(WHYNTER_ZERO_SPACE);
			}
		}

		// Footer
		mark(WHYNTER_ZERO_MARK);
		space(WHYNTER_ZERO_SPACE);  // Always end with the LED off
	}
#endif

void sendRaw(unsigned int buf[], int len, int hz){
	int i;
	enableIROut(hz);

	for (i = 0; i < len; i++) {
		if (i & 1) {
			space(buf[i]);
		}
		else {
			mark(buf[i]);
		}
	}
	space(0); // Just to be sure
}

void mark(int time) {
	// Sends an IR mark for the specified number of microseconds.
	// The mark output is modulated at the PWM frequency.
	TCCR1A |= _BV(COM1A1); // Enable pin 3 PWM output
	delayMicroseconds(time);
}

/* Leave pin off for time (given in microseconds) */
void space(int time) {
	// Sends an IR space for the specified number of microseconds.
	// A space is no output, so the PWM output is disabled.
	TCCR1A &= ~(_BV(COM1A1)); // Disable pin 3 PWM output
	delayMicroseconds(time);
}

//~ #endif


void enableIROut(int khz) {
	static uint16_t pwmval;
	// Enables IR output.  The khz value controls the modulation frequency in kilohertz.
	// The IR output will be on pin 3 (OC2B).
	// This routine is designed for 36-40KHz; if you use it for other values, it's up to you
	// to make sure it gives reasonable results.  (Watch out for overflow / underflow / rounding.)
	// TIMER2 is used in phase-correct PWM mode, with OCR2A controlling the frequency and OCR2B
	// controlling the duty cycle.
	// There is no prescaling, so the output frequency is 16MHz / (2 * OCR2A)
	// To turn the output on and off, we leave the PWM running, but connect and disconnect the output pin.
	// A few hours staring at the ATmega documentation and this will all make sense.
	// See my Secrets of Arduino PWM at http://arcfn.com/2009/07/secrets-of-arduino-pwm.html for details.


	// Disable the Timer2 Interrupt (which is used for receiving IR)
	//TIMER_DISABLE_INTR; //Timer2 Overflow Interrupt

	/*pinMode(TIMER_PWM_PIN, OUTPUT);*/
	PORTB |= _BV(1);

	//digitalWrite(TIMER_PWM_PIN, HIGH); // When not sending PWM, we want it low
 //


	// COM2A = 00: disconnect OC2A
	// COM2B = 00: disconnect OC2B; to send signal set to 10: OC2B non-inverted
	// WGM2 = 101: phase-correct PWM with OCRA as top
	// CS2 = 000: no prescaling
	// The top value for the timer.  The modulation frequency will be SYSCLOCK / 2 / OCR2A.
	pwmval = 8000/khz;
	TCCR1A = _BV(WGM11);
	TCCR1B = _BV(WGM13)|_BV(CS10);
	ICR1 = pwmval;
	OCR1A = pwmval / 3;
	//TIMER_CONFIG_KHZ(khz);
}

static unsigned char daikin2[27] = {
  0x11, 0xDA, 0x27, 0xF0, 0x00, 0x00, 0x00, 0x2, 
  0x11, 0xDA, 0x27, 0x00, 0x00, 0x31, 0x32, 0x00, 
  0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC1, 0x80, 0x00, 0x26}; 

int main(){
	DDRB |= _BV(1); //PB1
	PORTB &= ~_BV(1);
	while(1){
		sendDaikin(daikin2, 8,0);
		delay(29);
		sendDaikin(daikin2, 19,8);
		PORTB &= ~_BV(1);
		delay(2000);
	}
}
